<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Word Cloud</title>
  <style>
    canvas {
      display: block;
      margin: 0 auto;
      background: #f5f5f5;
    }
  </style>
  <!-- Load d3.js -->
  <script src="https://d3js.org/d3.v4.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/holtzy/D3-graph-gallery@master/LIB/d3.layout.cloud.js"></script>
</head>
<body>
  <div id="my_dataviz"></div>
  <script defer>
    const data = {
      top_50_words: [
        ["da", 8201], ["ni", 5772], ["ma", 5383], ["echt", 4916], 
        ["das", 4491], ["jij", 2342], ["okay", 1984], ["jou", 1973], 
        ["nee", 1638], ["ga", 1421], ["heel", 1337], ["je", 1331], 
        ["goed", 1222], ["ah", 1081], ["gaan", 1073], ["yep", 1071]
      ]
    };

    const r = (a, b, t=768) => window.innerWidth > t ? a : b
    let lastWidth;
let lastCloudWidth;

    function nWordsForCloud(n) {
  if (!data.top_50_words) {
    return []
  }
  let wordList = []
  const words = Object.fromEntries(data.top_50_words);
  Object.keys(words)
    .forEach(key => {
      wordList.push({word: key, size: words[key].toString()})
    })
  wordList = wordList.sort((a,b) => {
    return +b.size - +a.size
  })
  return cloudNormalize(wordList.slice(0,n))
}

function cloudNormalize(wordList) {
  const max = wordList[0].size
  const min = wordList[wordList.length - 1].size
  const cloudMax = r(150,95)
  const cloudMin = r(25,10)
  return wordList.map(el => {
    const zeroToOne = (el.size - min) / (max - min)
    const normalized = (zeroToOne*(cloudMax - cloudMin)) + cloudMin
    return {...el, size: normalized}
  })
}

function drawCloud() {
  // List of words
  let myWords = nWordsForCloud(75)
  // set the dimensions and margins of the graph
  let margin = {top: 10, right: 10, bottom: 10, left: 10}
  width = r(r(750, 350), 300, 370) - margin.left - margin.right
  height = r(450, 250) - margin.top - margin.bottom;

  if (width === lastCloudWidth) {
    console.log('don\'t redraw')
    return
  }
  lastCloudWidth = width
  document.querySelector("#my_dataviz").innerHTML = ""

  // append the svg object to the body of the page
  let svg = d3.select("#my_dataviz").append("svg")
  .attr("width", width + margin.left + margin.right)
  .attr("height", height + margin.top + margin.bottom)
  .append("g")
  .attr("transform",
  "translate(" + margin.left + "," + margin.top + ")");

  // Constructs a new cloud layout instance. It run an algorithm to find the position of words that suits your requirements
  // Wordcloud features that are different from one word to the other must be here
  let layout = d3.layout.cloud()
  .size([width, height])
  .words(myWords.map(function(d) { return {text: d.word, size:d.size}; }))
  .padding(r(5,1))        //space between words
  .rotate(function() { return ~~(Math.random()) * 90; })
  .fontSize(function(d) { return d.size; })      // font size of words
  .on("end", draw);
  layout.start();

  // This function takes the output of 'layout' above and draw the words
  // Wordcloud features that are THE SAME from one word to the other can be here
  function draw(words) {
    svg
    .append("g")
    .attr("transform", "translate(" + layout.size()[0] / 2 + "," + layout.size()[1] / 2 + ")")
    .selectAll("text")
    .data(words)
    .enter().append("text")
    .style("font-size", function(d) { return d.size; })
    .style("fill", function(d) {
      if (d.x < -1 * (width*0.37)) { // too far left has to be grey to be visible
        return "#c6c6c6"
      }
      return Math.random() > 0.5 ? "#4ACA59" : "#c6c6c6"
    })
    .attr("text-anchor", "middle")
    .style("font-family", "Helvetica")
    .attr("transform", function(d) {
      return "translate(" + [d.x, d.y] + ")rotate(" + d.rotate + ")";
    })
    .text(function(d) {
      return d.text; });
  }
}
drawCloud()

async function shareDiv(query, selectors = []) {
  try {
    const div = document.querySelector(query)
    div.classList.add('frame')
    const bubble = document.querySelector('.bubble').cloneNode(true)
    const p = document.createElement('p')
    p.classList.add('plug', 'center-for-ss')
    p.innerHTML = 'Created with <span class="shareable-link">WhatsAppWrapped.tech</span>'
    div.insertBefore(bubble, div.childNodes[0])
    div.append(p)
    div.classList.add('bg-img')
    selectors.forEach(s => document.querySelector(s).classList.add('center-for-ss'))
    const canvas = await html2canvas(div)
    selectors.forEach(s => document.querySelector(s).classList.remove('center-for-ss'))
    div.removeChild(bubble)
    div.removeChild(p)
    div.classList.remove('frame', 'bg-img')
    const url = canvas.toDataURL()
    const res1 = await fetch(url)
    const blob = await res1.blob()
    const file = new File([blob], 'wrapped_pic.png', {type: blob.type, lastModified:new Date()});
    if (!file) return
    const data = {files: [file]}
    if (navigator.canShare(data)) {
      navigator.share(data)
    }
  } catch (e) {
    console.error('error generating graphic', e)
  }
}

// redraw chart when window resizes
window.addEventListener('resize', () => {
  drawCloud()
})
drawCloud();
  </script>

</body>
</html>
